<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>簡易ローグライクゲーム</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+1+Code:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'M PLUS 1 Code', monospace;
            overscroll-behavior: none; /* Disable pull-to-refresh */
        }
        .touch-control {
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            user-select: none;
            cursor: pointer;
        }
        .touch-control:active {
            background-color: rgba(255, 255, 255, 0.4);
        }
        #map-container {
            line-height: 1.2;
            letter-spacing: 0.1em;
            overflow: hidden;
            font-size: clamp(12px, 3vw, 20px);
            min-height: 320px; /* Ensure a consistent height */
        }
        #map-container.initial {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type=number] {
            -moz-appearance: textfield;
        }
    </style>
</head>
<body class="bg-black text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div id="game-container" class="w-full max-w-5xl mx-auto flex flex-col gap-4">
        <!-- Top Section: Game Area + Controls -->
        <div class="flex flex-col lg:flex-row gap-4">
            <!-- Game Display Area -->
            <div class="flex-grow bg-gray-900 rounded-lg p-4 shadow-lg border border-gray-700">
                <h1 class="text-2xl font-bold text-center text-cyan-400 mb-4">簡易ローグライク</h1>
                <div id="map-container" class="bg-black rounded p-2 text-center select-none">
                    <!-- Map or Welcome message will be rendered here -->
                </div>
            </div>

            <!-- Control Panel Area: FIX - Combined into a single card that stretches -->
            <div class="w-full lg:w-80 flex-shrink-0 flex flex-col gap-4 bg-gray-900 rounded-lg p-4 shadow-lg border border-gray-700">
                <!-- Status Panel -->
                <div id="status-panel">
                    <h2 class="text-xl font-bold text-yellow-400 mb-2">ステータス</h2>
                    <div id="status" class="space-y-1">
                        <!-- Status will be rendered here -->
                    </div>
                </div>

                <!-- Settings Panel -->
                <div id="settings-panel">
                    <h2 class="text-xl font-bold text-yellow-400 mb-2 mt-4">設定</h2>
                     <div class="space-y-3">
                        <div>
                            <label for="monster-count" class="block text-sm text-gray-300 mb-1">モンスター初期数 (0-20)</label>
                            <input type="number" id="monster-count" value="10" min="0" max="20" class="w-full bg-gray-800 text-white p-2 rounded border border-gray-600 focus:outline-none focus:ring-2 focus:ring-cyan-500">
                        </div>
                        <div>
                            <label for="potion-count" class="block text-sm text-gray-300 mb-1">ポーション数 (0-10)</label>
                            <input type="number" id="potion-count" value="10" min="0" max="10" class="w-full bg-gray-800 text-white p-2 rounded border border-gray-600 focus:outline-none focus:ring-2 focus:ring-cyan-500">
                        </div>
                        <p class="text-xs text-gray-500 pt-1">※設定は「新しいゲーム」を押した時に反映されます。</p>
                    </div>
                </div>
                 <!-- FIX: Added mt-auto to push button to the bottom -->
                 <button id="start-reset-button" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded transition-colors duration-200 text-lg mt-auto">
                    新しいゲーム
                </button>
            </div>
        </div>

        <!-- Message Log Panel (Bottom) -->
        <div class="bg-gray-900 rounded-lg p-4 shadow-lg border border-gray-700 h-40 flex flex-col">
            <h2 class="text-xl font-bold text-green-400 mb-2">メッセージログ</h2>
            <div id="log" class="flex-grow bg-black rounded p-2 text-sm overflow-y-auto flex flex-col-reverse">
                <!-- Log messages will be rendered here -->
            </div>
        </div>

        <!-- Touch Controls for Mobile -->
        <div id="touch-controls" class="fixed bottom-5 right-5 mt-4 grid grid-cols-3 gap-2 w-48 lg:hidden">
            <div></div><div id="touch-up" class="touch-control">↑</div><div></div>
            <div id="touch-left" class="touch-control">←</div><div></div><div id="touch-right" class="touch-control">→</div>
            <div></div><div id="touch-down" class="touch-control">↓</div><div></div>
        </div>
    </div>


    <script>
        // --- DOM Elements ---
        const monsterCountInput = document.getElementById('monster-count');
        const potionCountInput = document.getElementById('potion-count');
        const startResetButton = document.getElementById('start-reset-button');
        
        const mapContainer = document.getElementById('map-container');
        const statusContainer = document.getElementById('status');
        const logContainer = document.getElementById('log');
        const statusPanel = document.getElementById('status-panel');

        // --- Game Constants ---
        const MAP_WIDTH = 35;
        const MAP_HEIGHT = 20;

        const TILES = {
            EMPTY: ' ',
            FLOOR: '<span class="text-gray-500">.</span>',
            WALL: '<span class="text-gray-400">#</span>',
            PLAYER: '<span class="text-white font-bold">@</span>',
            MONSTER: '<span class="text-red-500 font-bold">g</span>',
            POTION: '<span class="text-blue-400 font-bold">p</span>',
            STAIRS: '<span class="text-yellow-400 font-bold">&gt;</span>'
        };

        // --- Game State ---
        let map, player, monsters, items;
        let gameOver = true, turn = 0, floor = 0, maxFloor = 0;
        let baseMonsterCount, potionCount;

        // --- Game Logic ---
        
        function setupInitialScreen() {
            gameOver = true;
            mapContainer.classList.add('initial');
            mapContainer.innerHTML = '<div class="text-gray-400">「ゲーム開始」を押して開始</div>';
            
            statusContainer.innerHTML = `
                <p>階層: -</p>
                <p>HP: - / -</p>
                <p>[<span class="text-gray-600">----------</span>]</p>
                <p>Turn: -</p>
            `;

            clearLog();
            addLog("ようこそ！設定を調整してゲームを開始してください。");
            startResetButton.textContent = "ゲーム開始";
            startResetButton.classList.remove('bg-red-600', 'hover:bg-red-700');
            startResetButton.classList.add('bg-green-600', 'hover:bg-green-700');
        }

        function initGame() {
            let monsterVal = parseInt(monsterCountInput.value);
            let potionVal = parseInt(potionCountInput.value);
            
            if (isNaN(monsterVal)) monsterVal = 10;
            if (isNaN(potionVal)) potionVal = 10;

            baseMonsterCount = Math.max(0, Math.min(20, monsterVal));
            potionCount = Math.max(0, Math.min(10, potionVal));

            monsterCountInput.value = baseMonsterCount;
            potionCountInput.value = potionCount;
            
            mapContainer.classList.remove('initial');

            gameOver = false; 
            player = { x: 0, y: 0, hp: 10, maxHp: 10 };
            floor = 0;
            maxFloor = 0;
            
            clearLog();
            addLog('ダンジョンへようこそ！');
            
            startResetButton.textContent = "新しいゲーム";
            startResetButton.classList.remove('bg-green-600', 'hover:bg-green-700');
            startResetButton.classList.add('bg-red-600', 'hover:bg-red-700');
            
            nextFloor(); 
        }

        function nextFloor() {
            floor++;
            maxFloor = Math.max(floor, maxFloor);
            turn = 1;

            if (player) player.hp = player.maxHp;
            if (floor > 1) addLog(`地下${floor}階に降りた。HPが全回復した。`);

            map = generateMap();
            monsters = [];
            items = [];
            
            const playerStart = placePlayer();
            player.x = playerStart.x;
            player.y = playerStart.y;
            
            placeEntities(baseMonsterCount + (floor - 1), 'monster'); 
            placeEntities(potionCount, 'potion');
            placeEntities(1, 'stairs');
            
            drawAll();
        }

        function generateMap() {
            const newMap = Array.from({ length: MAP_HEIGHT }, () => Array(MAP_WIDTH).fill(TILES.WALL));
            const rooms = [];
            const numRooms = 5 + Math.floor(Math.random() * 5);

            for (let i = 0; i < numRooms; i++) {
                const w = 4 + Math.floor(Math.random() * 6);
                const h = 4 + Math.floor(Math.random() * 6);
                const x = 1 + Math.floor(Math.random() * (MAP_WIDTH - w - 2));
                const y = 1 + Math.floor(Math.random() * (MAP_HEIGHT - h - 2));
                
                const newRoom = { x, y, w, h };
                let failed = false;
                for (const otherRoom of rooms) {
                    if (isRectOverlap(newRoom, otherRoom)) {
                        failed = true;
                        break;
                    }
                }
                if (!failed) {
                    createRoom(newMap, newRoom);
                    if (rooms.length > 0) {
                        const prevRoom = rooms[rooms.length - 1];
                        connectRooms(newMap, prevRoom, newRoom);
                    }
                    rooms.push(newRoom);
                }
            }
            return newMap;
        }
        
        function isRectOverlap(r1, r2) {
             return (r1.x < r2.x + r2.w && r1.x + r1.w > r2.x &&
                    r1.y < r2.y + r2.h && r1.y + r1.h > r2.y);
        }

        function createRoom(map, room) {
            for (let y = room.y; y < room.y + room.h; y++) {
                for (let x = room.x; x < room.x + room.w; x++) {
                    map[y][x] = TILES.FLOOR;
                }
            }
        }
        
        function connectRooms(map, room1, room2) {
            const center1 = { x: room1.x + Math.floor(room1.w/2), y: room1.y + Math.floor(room1.h/2)};
            const center2 = { x: room2.x + Math.floor(room2.w/2), y: room2.y + Math.floor(room2.h/2)};
            let x = center1.x;
            let y = center1.y;
            while(x !== center2.x || y !== center2.y) {
                 if (x !== center2.x && Math.random() < 0.5) {
                    map[y][x] = TILES.FLOOR;
                    x += Math.sign(center2.x - x);
                } else if (y !== center2.y) {
                    map[y][x] = TILES.FLOOR;
                    y += Math.sign(center2.y - y);
                } else {
                    map[y][x] = TILES.FLOOR;
                    x += Math.sign(center2.x - x);
                }
            }
            map[y][x] = TILES.FLOOR;
        }

        function placePlayer() {
            let x, y;
            do {
                x = Math.floor(Math.random() * MAP_WIDTH);
                y = Math.floor(Math.random() * MAP_HEIGHT);
            } while (map[y][x] !== TILES.FLOOR);
            return { x, y };
        }

        function placeEntities(count, type) {
            const maxCount = count < 0 ? 0 : count;
            for (let i = 0; i < maxCount; i++) {
                let x, y, attempts = 0;
                do {
                    x = Math.floor(Math.random() * MAP_WIDTH);
                    y = Math.floor(Math.random() * MAP_HEIGHT);
                    attempts++;
                } while ((map[y][x] !== TILES.FLOOR || isOccupied(x, y)) && attempts < 100);

                if (attempts >= 100) continue; 

                if (type === 'monster') {
                    monsters.push({ x, y, hp: 3, maxHp: 3 });
                } else if (type === 'potion') {
                    items.push({ x, y, type: 'potion' });
                } else if (type === 'stairs') {
                     items.push({ x, y, type: 'stairs' });
                }
            }
        }
        
        function isOccupied(x, y) {
            if (player && player.x === x && player.y === y) return true;
            if (monsters.some(m => m.x === x && m.y === y)) return true;
            if (items.some(i => i.x === x && i.y === y)) return true;
            return false;
        }

        function drawAll() {
            drawMap();
            drawStatus();
        }

        function drawMap() {
            let html = '';
            for (let y = 0; y < MAP_HEIGHT; y++) {
                let row = '';
                for (let x = 0; x < MAP_WIDTH; x++) {
                    const monster = monsters.find(m => m.x === x && m.y === y);
                    const item = items.find(i => i.x === x && i.y === y);

                    if (player.x === x && player.y === y) {
                        row += TILES.PLAYER;
                    } else if (monster) {
                        row += TILES.MONSTER;
                    } else if (item) {
                        row += item.type === 'potion' ? TILES.POTION : TILES.STAIRS;
                    } else {
                        row += map[y][x];
                    }
                }
                html += row + '<br>';
            }
            mapContainer.innerHTML = html;
        }

        function drawStatus() {
            const currentHp = Math.max(0, player.hp);
            const hpBar = `[<span class="text-red-400">${'♥'.repeat(currentHp)}</span><span class="text-gray-600">${'♥'.repeat(player.maxHp - currentHp)}</span>]`;
            
            statusContainer.innerHTML = `
                <p>階層: B${floor}F</p>
                <p>HP: ${player.hp} / ${player.maxHp}</p>
                <p>${hpBar}</p>
                <p>Turn: ${turn}</p>
            `;
        }

        function addLog(message) {
            const logEntry = document.createElement('p');
            logEntry.textContent = message;
            if (logContainer.firstChild) {
                logContainer.insertBefore(logEntry, logContainer.firstChild);
            } else {
                logContainer.appendChild(logEntry);
            }
            while (logContainer.children.length > 50) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }
        
        function clearLog() {
            logContainer.innerHTML = '';
        }
        
        function movePlayer(dx, dy) {
            if (gameOver) return;
            const newX = player.x + dx;
            const newY = player.y + dy;
            if (newX < 0 || newX >= MAP_WIDTH || newY < 0 || newY >= MAP_HEIGHT) return;
            if (map[newY][newX] === TILES.WALL) {
                addLog('壁にぶつかった。');
                return;
            }

            const monster = monsters.find(m => m.x === newX && m.y === newY);
            if (monster) {
                attack(player, monster);
            } else {
                player.x = newX;
                player.y = newY;
                const itemIndex = items.findIndex(i => i.x === player.x && i.y === player.y);
                if (itemIndex > -1) {
                    const item = items[itemIndex];
                    if (item.type === 'potion') {
                        player.hp = Math.min(player.maxHp, player.hp + 5);
                        addLog('ポーションを飲んでHPが5回復した！');
                        items.splice(itemIndex, 1);
                    } else if (item.type === 'stairs') {
                        nextFloor();
                        return;
                    }
                }
            }
            endPlayerTurn();
        }
        
        function endPlayerTurn() {
            turn++;
            moveMonsters();
            drawAll();
            checkGameOver();
        }

        function moveMonsters() {
            monsters.forEach(monster => {
                const dx = Math.sign(player.x - monster.x);
                const dy = Math.sign(player.y - monster.y);
                let targetX = monster.x;
                let targetY = monster.y;

                if (dx !== 0 && dy !== 0) {
                    if (Math.random() < 0.5) targetX += dx;
                    else targetY += dy;
                } else if (dx !== 0) targetX += dx;
                else if (dy !== 0) targetY += dy;

                if (targetX === player.x && targetY === player.y) {
                    attack(monster, player);
                } else if (canMoveTo(monster, targetX, targetY)) {
                    monster.x = targetX;
                    monster.y = targetY;
                }
            });
        }
        
        function canMoveTo(monster, x, y) {
            return map[y][x] !== TILES.WALL && !monsters.some(m => m !== monster && m.x === x && m.y === y);
        }

        function attack(attacker, defender) {
            const damage = 1; 
            defender.hp -= damage;
            const attackerName = attacker === player ? 'プレイヤー' : 'ゴブリン';
            const defenderName = defender === player ? 'プレイヤー' : 'ゴブリン';
            addLog(`${attackerName}は${defenderName}に${damage}のダメージを与えた！`);
            if (defender.hp <= 0) {
                addLog(`${defenderName}を倒した！`);
                if (defender !== player) monsters = monsters.filter(m => m !== defender);
            }
        }

        function checkGameOver() {
            if (player.hp <= 0 && !gameOver) {
                gameOver = true;
                addLog('あなたは倒れた... ゲームオーバー。');
                addLog(`到達階層: 地下${maxFloor}階`);
                startResetButton.textContent = "もう一度挑戦";
                startResetButton.classList.remove('bg-red-600', 'hover:bg-red-700');
                startResetButton.classList.add('bg-green-600', 'hover:bg-green-700');
            }
        }
        
        function handleKeyPress(e) {
            if (gameOver) return;
            
            let dx = 0, dy = 0;
            switch (e.key) {
                case 'ArrowUp': dy = -1; break;
                case 'ArrowDown': dy = 1; break;
                case 'ArrowLeft': dx = -1; break;
                case 'ArrowRight': dx = 1; break;
                default: return;
            }
            e.preventDefault();
            if (dx !== 0 || dy !== 0) movePlayer(dx, dy);
        }
        
        // --- Event Listeners ---
        window.addEventListener('keydown', handleKeyPress);
        startResetButton.addEventListener('click', initGame);

        // Touch controls setup
        document.getElementById('touch-up').addEventListener('click', () => movePlayer(0, -1));
        document.getElementById('touch-down').addEventListener('click', () => movePlayer(0, 1));
        document.getElementById('touch-left').addEventListener('click', () => movePlayer(-1, 0));
        document.getElementById('touch-right').addEventListener('click', () => movePlayer(1, 0));

        // --- Initial Load ---
        setupInitialScreen();
    </script>
</body>
</html>
